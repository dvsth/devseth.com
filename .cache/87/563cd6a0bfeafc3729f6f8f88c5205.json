{"id":"src/shaders/VolumetricLightCylinder.js","dependencies":[{"name":"C:\\Users\\Dev Seth\\Personal Programs\\devseth.com\\source\\package.json","includedInParent":true,"mtime":1597490265719},{"name":"three","loc":{"line":1,"column":23},"parent":"C:\\Users\\Dev Seth\\Personal Programs\\devseth.com\\source\\src\\shaders\\VolumetricLightCylinder.js","resolved":"C:\\Users\\Dev Seth\\Personal Programs\\devseth.com\\source\\node_modules\\three\\build\\three.module.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar THREE = _interopRequireWildcard(require(\"three\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nvar _default = function _default() {\n  return {\n    lights: true,\n    transparent: true,\n    depthWrite: false,\n    uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib['lights'], {\n      attenuation: {\n        value: 25.0\n      },\n      anglePower: {\n        value: 10.0\n      },\n      spotPosition: {\n        value: new THREE.Vector3(0, 0, 0)\n      }\n    }]),\n    vertexShader: \"\\n    #include <common>\\n\\n    struct PointLight {\\n      vec3 position;\\n      vec3 color;\\n      float distance;\\n      float decay;\\n      int shadow;\\n      float shadowBias;\\n      float shadowRadius;\\n      vec2 shadowMapSize;\\n      float shadowCameraNear;\\n      float shadowCameraFar;\\n    };\\n\\n    uniform PointLight pointLights[NUM_POINT_LIGHTS];\\n    uniform float viewMix;\\n\\n    varying vec4 vColor;\\n    varying vec3 vNormal;\\n    varying vec3 vWorldPosition;\\n\\n    float _punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n    \\tif( decayExponent > 0.0 ) {\\n    \\t\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n    \\t}\\n    \\treturn 1.0;\\n    }\\n\\n    void main() {\\n      vNormal = normalize(normalMatrix * normal);\\n\\n      vec4 worldPosition = modelMatrix * vec4(position, 1.0);\\n      vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\\n      gl_Position = projectionMatrix * modelViewPosition;\\n\\n      vec4 addedLights = vec4(0.1, 0.1, 0.1, 1.0);\\n      for(int l = 0; l < NUM_POINT_LIGHTS; l++) {\\n        float dist = distance(pointLights[l].position, worldPosition.xyz);\\n        addedLights.rgb += pointLights[l].color *\\n          _punctualLightIntensityToIrradianceFactor(\\n            dist,\\n            pointLights[l].distance,\\n            pointLights[l].decay\\n          );\\n      }\\n\\n      vWorldPosition = worldPosition.xyz;\\n      vColor = addedLights;\\n    }\\n  \",\n    fragmentShader: \"\\n    varying vec3 vNormal;\\n    varying vec3 vWorldPosition;\\n    uniform vec3 spotPosition;\\n    uniform float attenuation;\\n    uniform float anglePower;\\n    varying vec4 vColor;\\n\\n    void main() {\\n      float intensity;\\n      intensity\\t= distance(vWorldPosition, spotPosition)/attenuation;\\n      intensity\\t= 1.0 - clamp(intensity, 0.0, 1.0);\\n      vec3 normal\\t= vec3(vNormal.x, vNormal.y, abs(vNormal.z));\\n      float angleIntensity\\t= pow(dot(normal, vec3(0.0, 0.0, 1.0)), anglePower);\\n      intensity\\t= intensity * angleIntensity;\\n      gl_FragColor = vec4(vColor.rgb, intensity);\\n    }\\n  \"\n  };\n};\n\nexports.default = _default;"},"sourceMaps":{"js":{"mappings":[{"generated":{"line":8,"column":0},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":1,"column":0}},{"generated":{"line":14,"column":15},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":3,"column":15}},{"generated":{"line":15,"column":0},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":3,"column":15}},{"generated":{"line":15,"column":9},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":3,"column":22}},{"name":"lights","generated":{"line":16,"column":0},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":4,"column":2}},{"name":"lights","generated":{"line":16,"column":4},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":4,"column":2}},{"generated":{"line":16,"column":10},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":4,"column":8}},{"generated":{"line":16,"column":12},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":4,"column":10}},{"generated":{"line":16,"column":16},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":3,"column":22}},{"name":"transparent","generated":{"line":17,"column":0},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":5,"column":2}},{"name":"transparent","generated":{"line":17,"column":4},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":5,"column":2}},{"generated":{"line":17,"column":15},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":5,"column":13}},{"generated":{"line":17,"column":17},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":5,"column":15}},{"generated":{"line":17,"column":21},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":3,"column":22}},{"name":"depthWrite","generated":{"line":18,"column":0},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":6,"column":2}},{"name":"depthWrite","generated":{"line":18,"column":4},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":6,"column":2}},{"generated":{"line":18,"column":14},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":6,"column":12}},{"generated":{"line":18,"column":16},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":6,"column":14}},{"generated":{"line":18,"column":21},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":3,"column":22}},{"name":"uniforms","generated":{"line":19,"column":0},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":7,"column":2}},{"name":"uniforms","generated":{"line":19,"column":4},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":7,"column":2}},{"generated":{"line":19,"column":12},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":7,"column":10}},{"name":"THREE","generated":{"line":19,"column":14},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":7,"column":12}},{"generated":{"line":19,"column":19},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":7,"column":17}},{"name":"UniformsUtils","generated":{"line":19,"column":20},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":7,"column":18}},{"generated":{"line":19,"column":33},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":7,"column":12}},{"name":"merge","generated":{"line":19,"column":34},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":7,"column":32}},{"generated":{"line":19,"column":39},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":7,"column":12}},{"generated":{"line":19,"column":40},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":7,"column":38}},{"name":"THREE","generated":{"line":19,"column":41},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":8,"column":4}},{"generated":{"line":19,"column":46},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":8,"column":9}},{"name":"UniformsLib","generated":{"line":19,"column":47},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":8,"column":10}},{"generated":{"line":19,"column":58},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":8,"column":4}},{"generated":{"line":19,"column":59},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":8,"column":22}},{"generated":{"line":19,"column":67},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":8,"column":4}},{"generated":{"line":19,"column":68},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":7,"column":38}},{"generated":{"line":19,"column":70},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":9,"column":4}},{"name":"attenuation","generated":{"line":20,"column":0},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":10,"column":6}},{"name":"attenuation","generated":{"line":20,"column":6},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":10,"column":6}},{"generated":{"line":20,"column":17},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":10,"column":17}},{"generated":{"line":20,"column":19},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":10,"column":19}},{"name":"value","generated":{"line":21,"column":0},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":10,"column":21}},{"name":"value","generated":{"line":21,"column":8},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":10,"column":21}},{"generated":{"line":21,"column":13},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":10,"column":26}},{"generated":{"line":21,"column":15},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":10,"column":28}},{"generated":{"line":22,"column":0},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":10,"column":19}},{"generated":{"line":22,"column":7},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":9,"column":4}},{"name":"anglePower","generated":{"line":23,"column":0},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":11,"column":6}},{"name":"anglePower","generated":{"line":23,"column":6},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":11,"column":6}},{"generated":{"line":23,"column":16},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":11,"column":16}},{"generated":{"line":23,"column":18},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":11,"column":18}},{"name":"value","generated":{"line":24,"column":0},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":11,"column":20}},{"name":"value","generated":{"line":24,"column":8},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":11,"column":20}},{"generated":{"line":24,"column":13},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":11,"column":25}},{"generated":{"line":24,"column":15},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":11,"column":27}},{"generated":{"line":25,"column":0},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":11,"column":18}},{"generated":{"line":25,"column":7},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":9,"column":4}},{"name":"spotPosition","generated":{"line":26,"column":0},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":12,"column":6}},{"name":"spotPosition","generated":{"line":26,"column":6},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":12,"column":6}},{"generated":{"line":26,"column":18},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":12,"column":18}},{"generated":{"line":26,"column":20},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":12,"column":20}},{"name":"value","generated":{"line":27,"column":0},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":12,"column":22}},{"name":"value","generated":{"line":27,"column":8},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":12,"column":22}},{"generated":{"line":27,"column":13},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":12,"column":27}},{"generated":{"line":27,"column":15},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":12,"column":29}},{"name":"THREE","generated":{"line":27,"column":19},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":12,"column":33}},{"generated":{"line":27,"column":24},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":12,"column":38}},{"name":"Vector3","generated":{"line":27,"column":25},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":12,"column":39}},{"generated":{"line":27,"column":32},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":12,"column":29}},{"generated":{"line":27,"column":33},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":12,"column":47}},{"generated":{"line":27,"column":34},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":12,"column":29}},{"generated":{"line":27,"column":36},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":12,"column":50}},{"generated":{"line":27,"column":37},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":12,"column":29}},{"generated":{"line":27,"column":39},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":12,"column":53}},{"generated":{"line":27,"column":40},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":12,"column":29}},{"generated":{"line":28,"column":0},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":12,"column":20}},{"generated":{"line":29,"column":0},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":9,"column":4}},{"generated":{"line":29,"column":5},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":7,"column":38}},{"generated":{"line":29,"column":6},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":7,"column":12}},{"generated":{"line":29,"column":7},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":3,"column":22}},{"name":"vertexShader","generated":{"line":30,"column":0},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":15,"column":2}},{"name":"vertexShader","generated":{"line":30,"column":4},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":15,"column":2}},{"generated":{"line":30,"column":16},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":15,"column":14}},{"generated":{"line":30,"column":1556},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":3,"column":22}},{"name":"fragmentShader","generated":{"line":31,"column":0},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":67,"column":2}},{"name":"fragmentShader","generated":{"line":31,"column":4},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":67,"column":2}},{"generated":{"line":31,"column":18},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":67,"column":16}},{"generated":{"line":32,"column":0},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":3,"column":22}},{"generated":{"line":32,"column":3},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":3,"column":15}},{"generated":{"line":33,"column":0},"source":"src/shaders/VolumetricLightCylinder.js","original":{"line":3,"column":15}}],"sources":{"src/shaders/VolumetricLightCylinder.js":"import * as THREE from 'three'\r\n\r\nexport default () => ({\r\n  lights: true,\r\n  transparent: true,\r\n  depthWrite: false,\r\n  uniforms: THREE.UniformsUtils.merge([\r\n    THREE.UniformsLib['lights'],\r\n    {\r\n      attenuation: { value: 25.0 },\r\n      anglePower: { value: 10.0 },\r\n      spotPosition: { value: new THREE.Vector3(0, 0, 0) },\r\n    },\r\n  ]),\r\n  vertexShader: `\r\n    #include <common>\r\n\r\n    struct PointLight {\r\n      vec3 position;\r\n      vec3 color;\r\n      float distance;\r\n      float decay;\r\n      int shadow;\r\n      float shadowBias;\r\n      float shadowRadius;\r\n      vec2 shadowMapSize;\r\n      float shadowCameraNear;\r\n      float shadowCameraFar;\r\n    };\r\n\r\n    uniform PointLight pointLights[NUM_POINT_LIGHTS];\r\n    uniform float viewMix;\r\n\r\n    varying vec4 vColor;\r\n    varying vec3 vNormal;\r\n    varying vec3 vWorldPosition;\r\n\r\n    float _punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\r\n    \tif( decayExponent > 0.0 ) {\r\n    \t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\r\n    \t}\r\n    \treturn 1.0;\r\n    }\r\n\r\n    void main() {\r\n      vNormal = normalize(normalMatrix * normal);\r\n\r\n      vec4 worldPosition = modelMatrix * vec4(position, 1.0);\r\n      vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n      gl_Position = projectionMatrix * modelViewPosition;\r\n\r\n      vec4 addedLights = vec4(0.1, 0.1, 0.1, 1.0);\r\n      for(int l = 0; l < NUM_POINT_LIGHTS; l++) {\r\n        float dist = distance(pointLights[l].position, worldPosition.xyz);\r\n        addedLights.rgb += pointLights[l].color *\r\n          _punctualLightIntensityToIrradianceFactor(\r\n            dist,\r\n            pointLights[l].distance,\r\n            pointLights[l].decay\r\n          );\r\n      }\r\n\r\n      vWorldPosition = worldPosition.xyz;\r\n      vColor = addedLights;\r\n    }\r\n  `,\r\n  fragmentShader: `\r\n    varying vec3 vNormal;\r\n    varying vec3 vWorldPosition;\r\n    uniform vec3 spotPosition;\r\n    uniform float attenuation;\r\n    uniform float anglePower;\r\n    varying vec4 vColor;\r\n\r\n    void main() {\r\n      float intensity;\r\n      intensity\t= distance(vWorldPosition, spotPosition)/attenuation;\r\n      intensity\t= 1.0 - clamp(intensity, 0.0, 1.0);\r\n      vec3 normal\t= vec3(vNormal.x, vNormal.y, abs(vNormal.z));\r\n      float angleIntensity\t= pow(dot(normal, vec3(0.0, 0.0, 1.0)), anglePower);\r\n      intensity\t= intensity * angleIntensity;\r\n      gl_FragColor = vec4(vColor.rgb, intensity);\r\n    }\r\n  `,\r\n})\r\n"},"lineCount":null}},"error":null,"hash":"f4f3993d951836cfe1c5f214bcba6461","cacheData":{"env":{}}}