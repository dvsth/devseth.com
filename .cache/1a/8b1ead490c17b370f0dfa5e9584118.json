{"id":"Puiu","dependencies":[{"name":"C:\\Users\\Dev Seth\\Personal Programs\\devseth.com\\source\\package.json","includedInParent":true,"mtime":1594300498284},{"name":"three","loc":{"line":1,"column":23},"parent":"C:\\Users\\Dev Seth\\Personal Programs\\devseth.com\\source\\src\\shaders\\VolumetricLightCylinder.js","resolved":"C:\\Users\\Dev Seth\\Personal Programs\\devseth.com\\source\\node_modules\\three\\build\\three.module.js"}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.default=void 0;var n=o(require(\"three\"));function t(){if(\"function\"!=typeof WeakMap)return null;var n=new WeakMap;return t=function(){return n},n}function o(n){if(n&&n.__esModule)return n;if(null===n||\"object\"!=typeof n&&\"function\"!=typeof n)return{default:n};var o=t();if(o&&o.has(n))return o.get(n);var e={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var r in n)if(Object.prototype.hasOwnProperty.call(n,r)){var a=i?Object.getOwnPropertyDescriptor(n,r):null;a&&(a.get||a.set)?Object.defineProperty(e,r,a):e[r]=n[r]}return e.default=n,o&&o.set(n,e),e}var e=function(){return{lights:!0,transparent:!0,depthWrite:!1,uniforms:n.UniformsUtils.merge([n.UniformsLib.lights,{attenuation:{value:25},anglePower:{value:10},spotPosition:{value:new n.Vector3(0,0,0)}}]),vertexShader:\"\\n    #include <common>\\n\\n    struct PointLight {\\n      vec3 position;\\n      vec3 color;\\n      float distance;\\n      float decay;\\n      int shadow;\\n      float shadowBias;\\n      float shadowRadius;\\n      vec2 shadowMapSize;\\n      float shadowCameraNear;\\n      float shadowCameraFar;\\n    };\\n\\n    uniform PointLight pointLights[NUM_POINT_LIGHTS];\\n    uniform float viewMix;\\n\\n    varying vec4 vColor;\\n    varying vec3 vNormal;\\n    varying vec3 vWorldPosition;\\n\\n    float _punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n    \\tif( decayExponent > 0.0 ) {\\n    \\t\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n    \\t}\\n    \\treturn 1.0;\\n    }\\n\\n    void main() {\\n      vNormal = normalize(normalMatrix * normal);\\n\\n      vec4 worldPosition = modelMatrix * vec4(position, 1.0);\\n      vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\\n      gl_Position = projectionMatrix * modelViewPosition;\\n\\n      vec4 addedLights = vec4(0.1, 0.1, 0.1, 1.0);\\n      for(int l = 0; l < NUM_POINT_LIGHTS; l++) {\\n        float dist = distance(pointLights[l].position, worldPosition.xyz);\\n        addedLights.rgb += pointLights[l].color *\\n          _punctualLightIntensityToIrradianceFactor(\\n            dist,\\n            pointLights[l].distance,\\n            pointLights[l].decay\\n          );\\n      }\\n\\n      vWorldPosition = worldPosition.xyz;\\n      vColor = addedLights;\\n    }\\n  \",fragmentShader:\"\\n    varying vec3 vNormal;\\n    varying vec3 vWorldPosition;\\n    uniform vec3 spotPosition;\\n    uniform float attenuation;\\n    uniform float anglePower;\\n    varying vec4 vColor;\\n\\n    void main() {\\n      float intensity;\\n      intensity\\t= distance(vWorldPosition, spotPosition)/attenuation;\\n      intensity\\t= 1.0 - clamp(intensity, 0.0, 1.0);\\n      vec3 normal\\t= vec3(vNormal.x, vNormal.y, abs(vNormal.z));\\n      float angleIntensity\\t= pow(dot(normal, vec3(0.0, 0.0, 1.0)), anglePower);\\n      intensity\\t= intensity * angleIntensity;\\n      gl_FragColor = vec4(vColor.rgb, intensity);\\n    }\\n  \"}};exports.default=e;"},"sourceMaps":null,"error":null,"hash":"1ef56fb00e3e5d56dbabe9fda27dbfe2","cacheData":{"env":{}}}